/**Number of different lines of inputs (a line is composed by an input for a character and one for a frequency).
@type {Number}*/ 
var inputs = 1;

/**Default code for an line of inputs.
@type {String}*/
var divInput = '<div class="form-group form-row"><div class="col" data-content="Character missing" data-placement="left"><input type="text" class="carinput form-control form-control-sm" placeholder="Character"></div><div class="col" data-content="Weight missing" data-placement="right"><input type="number" class="occinput form-control form-control-sm" min="0" step="any" placeholder="Weight"></div></div>';

/**
Frequencies of the 26 latin characters in the French language.
It was generated by typing the values found on the web into this page.
@type {String}
*/
var frenchJson = '[[13.98,"e"],[7.542,"s"],[7.246,"a"],[7.144,"i"],[6.874,"t"],[6.732,"n"],[6.218,"r"],[5.988,"u"],[5.177,"l"],[5.121,"o"],[3.481,"d"],[3.094,"c"],[2.867,"p"],[2.816,"m"],[1.807,"é"],[1.545,"v"],[1.372,","],[1.359,"\'"],[1.292,"q"],[1.012,"f"],[0.861,"."],[0.855,"b"],[0.822,"g"],[0.699,"h"],[0.517,"j"],[0.461,"à"],[0.426,"-"],[0.367,"x"],[0.292,"y"],[0.257,"è"],[0.213,"ê"],[0.206,"\\\""],[0.129,"z"],[0.119,":"],[0.108,"w"],[0.1,")"],[0.093,"("],[0.081,"ç"],[0.073,"0"],[0.071,"/"],[0.068,"?"],[0.058,";"],[0.055,"ù"],[0.054,"!"],[0.048,"1"],[0.046,"k"],[0.045,"2"],[0.043,"î"],[0.03,"3"],[0.018,"9"],[0.017,"5"],[0.015,"4"],[0.012,"7"],[0.012,"6"],[0.011,"8"],[0.009,"*"],[0.006,"œ"],[0.005,"ï"],[0.005,"="],[0.004,"@"],[0.004,"+"],[0.004,">"],[0.003,"]"],[0.003,"["],[0.003,"%"],[0.003,"<"],[0.001,"&"],[0.001,"|"],[0.001,"#"],[0.001,"$"],[0.0005,"ë"],[0.0005,"~"],[15," "]]';

/**
Variable used to store binary codes generated by the script.
@type {Object}
*/
var codes = {};

/**Name of the localStorage key to access the keys and names of the stored dictionnaries.
@type {String}*/
var dictListName = "dictList";

// Adds to the HTML the first row of inputs
$('#inputsValues').append(divInput);

// Initializes the tooltips when a field is missing in a row of inputs or when a tree name contains a dot.
$('[data-toggle]').popover();

/**
Is used to save or retrieve a localStorage value (a string saved to the user's browser).
@param {String} key - Key used to save and name the dictionnary.
@param {String} [string=""] - String to be saved to the browser. If not used, it will be used to try to retrieve the value at the key.
@returns {(Boolean|String)} Returns true if the setItem worked, false if the getItem at key didn't find an object or the value if it found it.
*/
function manageStorage(key, string=""){
	// If a string is given, we edit the item at the key.
	if(string){
		localStorage.setItem(key, string);
		return true;
	// If no string is given, we are looking to retrieve the item at the key.
	}else{
		var value;
		if(value = localStorage.getItem(key)){
			return value;
		}else{
			return false;
		}
	}
}

/**
Is used to save or update a named dictionnary representing a tree into the browser's local storage as a JSONified string.
@param {Array} fields - List of inputs given by the checkInputs function.
@param {String} label - Name of the tree.
*/
function saveDict(fields, label){
	var fieldsStr = JSON.stringify(fields);
	// We use our local function to store the new JSONified dictionnary
	manageStorage(label, fieldsStr);
	// It is used to retrieve the names of stored trees.
	var dictList;
	console.log("Dictionnary saved.")

	// If a dictionnary list already existed, we retrieve it.
	if(dictList = manageStorage(dictListName)){
		// Dictionnaries' name are stored as a string separated by a dot.
		dictList = dictList.split(".");
		// If we don't find in the list the name of the dictionnary to save, we add it.
		if(dictList.indexOf(label) == -1){
			dictList.push(label);
			dictList = dictList.join(".");
			manageStorage(dictListName, dictList);
			console.log("New key added in dictionnary list.");
		}
	// If no list was already saved, we just save our dictionnary list into a new dictionnary list.
	}else{
		manageStorage(dictListName, label);
		console.log("No previous dictionnary list existed. Created a new one.");
	}

	// Updates the list of dictionnaries to load.
	updateDictSelect();
}

function loadDict(label){

	var fields = JSON.parse(manageStorage(label));
	codes = createCodeFromTree(createTreeFromArray(fields));
	$('#dictCodes').html(createHtmlTableFromObject(codes));

	$('#inputsValues > div').each(function(){
		$(this).find(".carinput").val(null);
		$(this).find(".occinput").val(null);
		$(this).find("input").trigger("change");
	});

	for (var i = 0; i < fields.length; i++) {
		var lastJquery = $("#inputsValues > div:last");
		lastJquery.find(".carinput").val(fields[i][1]);
		lastJquery.find(".occinput").val(fields[i][0]);
		lastJquery.find("input").trigger("change");
	}

	$('#dictCodesCollapse').collapse("show");
	$('#dictCreationCollapse').collapse("show");

}

/**
Deletes the dictionnary from the user's browser.
@param {string} label - Name of the stored tree to delete.
*/
function removeDict(label){
	localStorage.removeItem(label);
	// We retrieve all labels as an array.
	var listDicts = localStorage.getItem(dictListName).split(".");
	// We found the label and remove it from the array, which we put back together with dots.
	var indexLabel = listDicts.indexOf(label);
	listDicts.splice(indexLabel, 1);
	listDicts = listDicts.join(".");
	// If our list doesn't have at least a dictionnary, we clear all of the storage. Else we save the new list.
	if(listDicts.length > 0){
		manageStorage(dictListName, listDicts);
	}else{
		localStorage.clear();
	}

	// Updates the list of dictionnaries to load.
	updateDictSelect();
}

/**
Generates the select field which displays all saved trees and allows to select one.
*/
function updateDictSelect(){
	// Clears the select content.
	$("#savedDicts").html("");
	var listDicts = localStorage.getItem(dictListName);
	// If dictionnaries are stored we add them to the select. Else we just add a simple option to display to the user.
	if(listDicts){
		listDicts = listDicts.split(".");
		$('#savedDicts').append("<option disabled selected>Choose a tree</option>");
		for(var value in listDicts){
			$("#savedDicts").append("<option value=\""+ listDicts[value] +"\">"+ listDicts[value] +"</option>");
		}
	}else{
		$('#savedDicts').append("<option disabled selected>No tree saved</option>");
	}
}

/**
Used to check whether an input is empty or not.
@param {jQuery} item - A jQuery's input selector.
*/
function isFieldEmpty(item){
	if(item.val()){
		return false;
	}else{
		return true;
	}
}

/**
Creates the binary codes from a tree.
@param {Tree} tree - Tree to use to generate binary codes for each character.
*/
function createCodeFromTree(tree){

	var codes = {};


	/**
	Recursive function used to attribute binary codes to each leaf (each character)
	by branching through each node and adding a "0" or "1" to the binary code if we either go to the "left" or "right".
	A tree is an array representative of a Huffman tree, with each array within being another node or a leaf.
	Each array has at index 0 the sum of the weights of both branches.
	Index 1 and 2 represent a branch and are arrays. If you go into them, you can find another node or a leaf.
	A leaf will have at index 0 the frequency (the weight) of its character, and at index 1 the character itself.
	@param {Tree} node - A node of the tree, which can be the root to launch the recursive function.
	@param {String} code - Current binary code as a string for the current node.
	*/
	function seekInBranch(node, code){

		if(Array.isArray(node[1])){
			seekInBranch(node[1], (code+"1"));
		}else{
			codes[node[1]] = code;
			console.log(`Found character, adding "${code}" for ${node[1]}`);
		}

		if(node[2]){

			if(Array.isArray(node[2])){
				seekInBranch(node[2], (code+"0"));
			}else{
				codes[node[2]] = code;
				console.log(`Found character, adding "${code} for ${node[2]}"`);
			}

		}

	}

	// We start from the top node, and the recursive function will reach every leaf.
	seekInBranch(tree[0], "");

	console.log(`Codes: ${JSON.stringify(codes)}`);
	return codes;

}

/**
Creates a tree from an array of values.
@param {Array} tableParam - Array of characters and frequencies. Ex: [[50, "A"], [60, "B"], [20, "C"]]
@returns {Tree} The tree created from the given table.
*/
function createTreeFromArray(tableParam){

	// This "hack" is used to create a copy of the object which is tableParam.
	var table = JSON.parse(JSON.stringify(tableParam));
	// Number of max decimals to process.
	var decimals = 4;

	function sortInputs(a, b){
		return a[0]-b[0];
	}

	// We sort each character's array by its weight at index 0. After that weights at the beginning are the least important, and those at the end are the most important.
	table.sort(sortInputs);

	var i = 0;
	var iterateMax = table.length;
	console.log(`Iterations max : ${iterateMax}`);
	
	// This loop takes the two lightest branches (real branches or leafs) then adds their weights.
	// A node is then created with at index 0 the weight of both branches, and at index 1 and 2 the branches.
	// We then add this new node to the list of nodes, we remove the two first branches which are now into the new node, and we resort branches by weight.
	// At the end it gives a tree with always lighter branches on the left (at index 1) than on the right (at index 2).
	while(table.length > 1 && i <= iterateMax){
		var newWeight = parseFloat((table[0][0] + table[1][0]).toFixed(decimals));
		var newNode = [newWeight, table[0], table[1]];
		table.push(newNode);
		table.splice(0,2);
		table.sort(sortInputs);
		i++;
	}

	console.log(`Tree: ${JSON.stringify(table)}`);
	return table;

}

/**
Used to check all created inputs and create an array with the values in it.
It also adds a warning if a input is invalid.
@returns {Array} Array of characters and frequencies used to later create a tree.
*/
function checkInputs(){
	
	var results = [];
	
	$('#inputsValues > div').each(function(){

		// If the character and the weight fields are filled, we add their values to the list of datas filled by the user.
		if(!isFieldEmpty($(this).find(".carinput")) && !isFieldEmpty($(this).find(".occinput"))){
			var car = $(this).find("div > .carinput").val();
			var occ = parseFloat($(this).find("div > .occinput").val());
			results.push([occ, car]);

		// If only the character's field is filled, we display a warning on the weight field.
		}else if(!isFieldEmpty($(this).find(".carinput"))){
			$(this).find(".occinput").addClass("is-invalid");
			$(this).find(".occinput").parent().popover("show");

		// If only the weight's field is filled, we display a warning on the character field.
		}else if(!isFieldEmpty($(this).find(".occinput"))){
			$(this).find(".carinput").addClass("is-invalid");
			$(this).find(".carinput").parent().popover("show");
		}

	});

	console.log(`${JSON.stringify(results)} : ${results.length} items`);
	return results;
}

/**
Used to add or remove lines of inputs if they are fully completed or if more than one line is empty.
@param {jQuery} item - Wrapper jQuery item of a line of inputs.
*/
function manageInputs(item){

	// If the character and weight fields are empty and we have at least more than one line of inputs, we can delete this line.
	if(isFieldEmpty(item.find(".carinput")) && isFieldEmpty(item.find(".occinput")) && inputs > 1){
		item.remove();
		inputs--;
	// As this function is called when modifying a line, if this one is completely filled, we add a new one.
	}else if(item.is(":last-child")){
		item.parent().append(divInput);
		inputs++;
	}
	console.log(`${inputs} inputs.`);

	manageSubmitDict();

}

/**
Enables or disables the button to create the tree according to the number of completed inputs.
*/
function manageSubmitDict(){

	// If we have more than one input lines (so if at least a line is completely filled), we enable the "Create tree" button/
	if(inputs > 1){
		$('#submitDict').removeAttr("disabled");
		console.log("Enabling submit dictionnary button");
	// Else we disable it.
	}else{
		$('#submitDict').attr("disabled", "disabled");
		console.log("Disabling submit dictionnary button");
	}

}

/**
Creates an HTML table to display the binary codes generated by a tree.
@param {BinaryCodes} obj - Dictionnary of binary codes generated with createCodeFromTree().
@returns {jQuery} The HTML code and jQuery object of the table.
*/
function createHtmlTableFromObject(obj){
	var html = $("<table></table>");
	html.addClass("table table-striped");
	html.html("<thead><tr><th>Character</th><th>Code</th></tr></thead><tbody></tbody>");
	html.find("thead").addClass("thead-light");
	for(var key in obj){
		html.children("tbody").append(`<tr><td>"${key}"</td><td>${obj[key]}</td></tr>`);
	}
	return html;
}

/**
Enables or disables the textarea to encrypt a text.
@param {Boolean} enable - Used to enable or disable the textarea.
*/
function enableTextToEncrypt(enable){
	if(enable){
		$("#submitEncryptForm").removeAttr("disabled");
		$("#encryptForm").removeAttr("disabled").attr("placeholder", $("#encryptForm").attr("placeholderEnabled"));
		console.log("Encryption form enabled.");
	}else{
		$("#submitEncryptForm").attr("disabled", "disabled");
		$("#encryptForm").attr("disabled", "disabled").attr("placeholder", $("#encryptForm").attr("placeholderDisabled"));
		console.log("Encryption form disabled.");
	}
}

/**
Enables or disables the textarea to decrypt a text.
@param {Boolean} enable - Used to enable or disable the textarea.
*/
function enableTextToDecrypt(enable){
	if(enable){
		$("#submitDecryptForm").removeAttr("disabled");
		$("#decryptForm").removeAttr("disabled").attr("placeholder", $("#decryptForm").attr("placeholderEnabled"));
		console.log("Decryption form enabled.");
	}else{
		$("#submitDecryptForm").attr("disabled", "disabled");
		$("#decryptForm").attr("disabled", "disabled").attr("placeholder", $("#decryptForm").attr("placeholderDisabled"));
		console.log("Decryption form disabled.");
	}
}

/**
Encrypt a given string with the global tree loaded.
@param {String} text - String to encrypt.
@returns {Boolean|Object} Either returns a false boolean if no tree is loaded, or an object with the encrypted result at "encrypt", the number of characters missed at "missed" and the list of unique missed characters at "listMissed".
*/
function encryptFromString(text){

	if(Object.keys(codes).length <= 0){
		console.log("No code to use!");
		return false;
	}

	var result = "";
	var missedChars = 0;
	var listMissedChars = [];

	for (var i = 0; i < text.length; i++) {
		if(text[i] in codes){
			result += codes[text[i]];
		}else{
			if(!listMissedChars.includes(text[i])){
				listMissedChars.push(text[i]);
			}
			missedChars++;
		}
	}

	var multipleReturns = {"encrypt": result, "missed": missedChars, "listMissed": listMissedChars};

	return multipleReturns;

}

/**
Decrypts a binary string following the loaded Huffman tree.
@param {String} text - String to decrypt.
@returns {String} Result of the decryption.
*/
function decryptFromString(text){

	/**
	Swap the keys and values of a dictionnary.
	@param {Object} objToSwap - Dictionnary whom the keys and values will be swapped.
	@returns {Object} Swapped dictionnary.
	*/
	function swap(objToSwap){
		var ret = {};
		for(var key in objToSwap){
			ret[objToSwap[key]] = key;
		}
		return ret;
	}

	var invertedCodes = swap(codes);
	var buffer = "";
	var result = "";

	for(var i in text){
		buffer += text[i];
		if(buffer in invertedCodes){
			result += invertedCodes[buffer];
			buffer = "";
		}
	}

	return result;

}

// Whenever a character or weight input is changed, we check whether we need a new line of inputs or we need to delete this one.
// We also remove tooltips before the manageInputs function reapplies them if necessary.
$('body').on('change', 'input.carinput, input.occinput', function(){
	manageInputs($(this).parent().parent());
	if(!isFieldEmpty($(this))){
		$(this).parent().popover("hide");
		$(this).parent().parent().find(".is-invalid").removeClass("is-invalid");
	}
});

// When the "Create tree" button is pressed, we retrieve all values in inputs, generate a tree and binary codes and update the page to show the results.
$('#dict').on('submit', function(event){
	event.preventDefault();

	var results = checkInputs();
	
	results = createTreeFromArray(results);
	if(results.length > 0){

		codes = createCodeFromTree(results);
		$('#dictCodes').html(createHtmlTableFromObject(codes));

		$('#saveDict').removeAttr("disabled");
		$('#dictCodesCollapse').collapse("show");

		enableTextToEncrypt(true);
		enableTextToDecrypt(true);

	}

});

// jQuery handles the collapsing effect of the save tree button. This event is called when we have typed a tree name and we clicked on "Save tree". jQuery hides the display and calls this event.
// It retrieves the name given by the user, and asks the script to save the current dictionnary with the given name.
// It doesn't save the dictionnary and sends an alert if it detects a dot in the name.
$('#dictNameCollapse').on('hide.bs.collapse', function(){
	$("#dictName").popover("hide");
	var userDictName = $('#dictName').val();
	if(userDictName.indexOf(".") == -1){
		$('#dictName').val("");
		saveDict(checkInputs(), userDictName);
	}else{
		alert("Sorry, the tree wasn't saved because of a dot in the name. Please retry with another name.");
	}
});

// This is called when we click on the "Save tree" button to display the input. jQuery displays it and calls this event.
// We just give the focus to the input.
// It also displays the dot tooltip.
$('#dictNameCollapse').on('shown.bs.collapse', function(){
	$("#dictName").popover("show");
	$('#dictName').focus();
});

// When the select input to choose a dictionnary to load is changed, we enable the buttons.
$("#savedDicts").on("change", function(){
	$("#loadDictButton").removeAttr("disabled");
	$('#deleteDictButton').removeAttr("disabled");
});

// Event called when we have choosen a dictionnary to load, and we pressed the button to do it.
$('#loadDict').on("submit", function(event){
	event.preventDefault();
	loadDict($("#savedDicts").val());
	enableTextToEncrypt(true);
	enableTextToDecrypt(true);
});

// It removes the selected dictionnary from the list.
$("#deleteDictButton").on("click", function(){
	removeDict($('#savedDicts').val());
});

// Encrypts and displays on the press of the submit button.
$("#formEncryptForm").on("submit", function(event){

	event.preventDefault();

	// Encrypts the typed string and displays it.
	var encrypted = encryptFromString($("#encryptForm").val());
	$("#encryptResult").val(encrypted["encrypt"]);

	// Adds the number of missed characters and displays it.
	$("#nbMissedCharacters").text(encrypted["missed"]);
	$("#encryptResultStats").removeClass("d-none");

	// If characters were missed, it displays a table with each one missed.
	// Or hides the table if it isn't needed.
	if(encrypted["missed"] > 0){
		$("#missedCharacters").find("tr").remove();
		for (var i = 0; i < encrypted["listMissed"].length; i++) {
			var row = "<tr><td>"+ encrypted["listMissed"][i] +"</td></tr>";
			$("#missedCharacters").append(row);
		}
		$("#missedCharacters").removeClass("d-none");
	}else{
		$("#missedCharacters").addClass("d-none");
	}

	// Show the collapsing tab.
	$("#encryptResultCollapse").collapse("show");

});

// Decrypts and displays on the press of the submit button.
$("#formDecryptForm").on("submit", function(event){

	event.preventDefault();

	var decrypted = decryptFromString($("#decryptForm").val());
	$("#decryptResult").val(decrypted);

	// Show the collapsing tab.
	$("#decryptResultCollapse").collapse("show");

});

// At the start of the script, we add a French dictionnary and we update the list of selectables dictionnaries.
$(document).ready(function(){
	saveDict(JSON.parse(frenchJson), "French");
	updateDictSelect();
});

